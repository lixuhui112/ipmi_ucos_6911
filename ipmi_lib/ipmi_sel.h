//*****************************************************************************
//
// ipmi_sel.h - IPMI Command Header File SEL Device Commands
//
// author:  qujianning@kyland.com.cn
// update:  2012/08/03
// version: v1.0
//
//*****************************************************************************

#ifndef __IPMI_SEL_H__
#define __IPMI_SEL_H__

#include <stdint.h>
#include <math.h>
#include "ipmi_lib/ipmi.h"

#define IPMI_SEL_VERSION            0x51

#define IPMI_SEL_ERASE_PROCESS      0x0001

#define IPMI_SEL_HEADER_OFFSET      0x1800  /* 0k (cpu) 2k (arm) 4k (sdr) 6k (sel) 8k */
#define IPMI_SEL_STORAGE_OFFSET     (IPMI_SEL_HEADER_OFFSET + (sizeof(sel_event_header)))
#define IPMI_MAX_SEL_BYTES          16
#define IPMI_MAX_SEL_ENTRIES        128
#define IPMI_MAX_SEL_SPACE          (IPMI_MAX_SEL_BYTES * IPMI_MAX_SEL_ENTRIES)
#define IPMI_SEL_INDEX_INC(X)       ((X + 1) % IPMI_MAX_SEL_ENTRIES)
#define IPMI_SEL_INDEX_DEC(X)       ((X + IPMI_MAX_SEL_ENTRIES - 1) % IPMI_MAX_SEL_ENTRIES)
#define IPMI_SEL_RECORD_INC(X)      ((X + IPMI_MAX_SEL_BYTES) % IPMI_MAX_SEL_SPACE)
#define IPMI_SEL_RECORD_DEC(X)      ((X + IPMI_MAX_SEL_SPACE - IPMI_MAX_SEL_BYTES) % IPMI_MAX_SEL_SPACE)

#pragma pack(1)
typedef struct sel_event_header_st {
    uint16_t number_of_entries;                     /* current numbers of sel entries */
    uint16_t count_of_entries;                      /* count of all entries */
    uint16_t free_space;                            /* free space in storage */
    uint16_t alloc_space;                           /* redundancy */
    uint16_t first_entry_index;
    uint16_t last_entry_index;
    uint32_t most_recent_addition_timestamp;
    uint32_t most_recent_erase_timestamp;
    uint32_t rev[3];                                /* fill to 32 byte */
} sel_event_header;

struct standard_spec_sel_rec {
    uint32_t timestamp;                             /* Time when event was logged. LS byte first. */
#ifdef __LITTLE_ENDIAN__
    uint8_t id_type:1,                              /* RqSA & LUN if event was generated from IPMB.
                                                       Software ID if event was generated from system software. */
            ipmb_slave_addr:7;
#else
    uint8_t ipmb_slave_addr:7,
            id_type:1;
#endif
#ifdef __LITTLE_ENDIAN__
    uint8_t ipmb_dev_lun:2,                         /* [1:0] - IPMB device LUN if byte 1 holds Slave Address. 00b otherwise. */
            reserved:2,                             /* [3:2] - reserved. Write as 00b. */
            channel_number:4;                       /* [7:4] - Channel number. Channel that event message was received over. 0h if the
                                                       event message was received via the system interface, primary IPMB, or
                                                       internally generated by the BMC. (New for IPMI v1.5. These bits were reserved
                                                       in IPMI v1.0) */
#else
    uint8_t channel_number:4,
            reserved:2,
            ipmb_dev_lun:2;
#endif
	uint8_t evm_rev;                                /* Event Message format version
	                                                   (=04h for events in this specification, 03h for IPMI v1.0 Event Messages.) */
	uint8_t sensor_type;                            /* Sensor Type Code for sensor that generated the event
	                                                   see Table 42-3, Sensor Type Codes */
	uint8_t sensor_num;
#ifdef __LITTLE_ENDIAN__
	uint8_t event_type:7;                           /* Event Type
                                                       Type of trigger for the event, e.g. critical threshold going high,
                                                       state asserted, etc.
                                                       Also indicates class of the event. E.g. discrete, threshold, or OEM.
                                                       The Event Type field is encoded using the Event/Reading Type Code.
                                                       See section 42.1, Event/Reading Type Codes.
                                                       [6:0] - Event Type Code */
	uint8_t event_dir:1;                            /* [7] - 0b = Assertion event.
                                                             1b = Deassertion event. */
#else
    uint8_t event_dir:1;
    uint8_t event_type:7;
#endif
#define DATA_BYTE2_SPECIFIED_MASK	    0xc0        /* event_data[0] bit mask */
#define DATA_BYTE3_SPECIFIED_MASK	    0x30        /* event_data[0] bit mask */
#define EVENT_OFFSET_MASK		        0x0f        /* event_data[0] bit mask */
	uint8_t	event_data[3];
};
#define SEL_OEM_TS_DATA_LEN		        6
#define SEL_OEM_NOTS_DATA_LEN		    13
struct oem_ts_spec_sel_rec{
	uint32_t timestamp;                             /* Time when event was logged (automatically added by SEL device).
	                                                   LS byte first. */
	uint8_t manf_id[3];                             /* Manufacturer ID (see Get Device ID command for definition) */
	uint8_t	oem_defined[SEL_OEM_TS_DATA_LEN];       /* OEM Defined. This is defined according to the manufacturer
	                                                   identified by the Manufacturer ID field. */
};
struct oem_nots_spec_sel_rec{
	uint8_t oem_defined[SEL_OEM_NOTS_DATA_LEN];     /* OEM Defined. This is defined by the system integrator. */
};

typedef struct sel_event_record_st {
    uint16_t record_id;                             /* ID used for SEL Record access.
                                                       The Record ID values 0000h and FFFFh have special meaning
                                                       in the Event Access commands and must not be used as Record ID
                                                       values for stored SEL Event Records. */
    uint8_t  record_type;                           /* [7:0] - Record Type
                                                       02h = system event record
                                                       C0h-DFh = OEM timestamped, bytes 8-16 OEM defined
                                                       E0h-FFh = OEM non-timestamped, bytes 4-16 OEM defined */
	union{
		struct standard_spec_sel_rec standard_type; /* 02h = system event record */
		struct oem_ts_spec_sel_rec oem_ts_type;     /* C0h-DFh = OEM system event record */
		struct oem_nots_spec_sel_rec oem_nots_type; /* E0h-FFh = OEM system event record */
	} sel_type;
} sel_event_record;
#pragma pack()

#define OVERFLOW_FLAG                                       0x80
#define DELETE_SEL_COMMAND_SUPPORTED                        0x08
#define PARTIAL_ADD_SEL_ENTRY_COMMAND_SUPPORTED             0x04
#define RESERVE_SEL_COMMAND_SUPPORTED                       0x02
#define GET_SEL_ALLOCATION_INFORMATION_COMMAND_SUPPORTED    0x01

#pragma pack(1)
struct sel_info_rsp {
    uint8_t  version;                               /* number of records */
    uint16_t number_of_entries;                     /*  */
    uint16_t free_space;
    uint32_t most_recent_addition_timestamp;
    uint32_t most_recent_erase_timestamp;
    uint8_t  operation_support;
};

struct sel_allocation_info_rsp {
    uint16_t number_of_possible_allocation_units;
    uint16_t allocation_unit_size_in_bytes;
    uint16_t number_of_free_allocation_units;
    uint16_t largest_free_block_in_allocation_units;
    uint8_t maximum_record_size_in_allocation_units;
};

struct get_sel_entry_req {
    uint16_t reservation_id;
    uint16_t sel_record_id;
    uint8_t offset_into_record;
    uint8_t bytes_to_read;
};

struct get_sel_entry_rsp {
    uint16_t next_sel_record_id;                /* Next SEL Record ID, LS Byte */
    uint8_t record_data[IPMI_MAX_SEL_BYTES];    /* Record Data, 16 bytes for entire record */
};

struct add_sel_entry_req {
    uint8_t record_data[IPMI_MAX_SEL_BYTES];
};

struct add_sel_entry_rsp {
    uint16_t added_record_id;
};

struct del_sel_entry_req {
    uint16_t reservation_id;
    uint16_t sel_record_id;
};

struct del_sel_entry_rsp {
    uint16_t deleted_record_id;
};

#define INITIATE_ERASE              0xAA
#define GET_ERASURE_STATUS          0x00

struct clear_sel_req {
    uint8_t reservation_id_lsb;
    uint8_t reservation_id_msb;
    uint8_t char_c;                             /* ¡®C¡¯ (43h) */
    uint8_t char_l;                             /* ¡®L¡¯ (4Ch) */
    uint8_t char_r;                             /* ¡®R¡¯ (52h) */
    uint8_t operation;                          /* AAh = initiate erase.
                                                   00h = get erasure status. */
};

struct clear_sel_rsp {
#ifdef __LITTLE_ENDIAN__
    uint8_t erasure_progress:4,                 /* [3:0] - erasure progress
                                                   0h = erasure in progress.
                                                   1h = erase completed. */
            reserved:4;                         /* [7:4] - reserved */
#else
    uint8_t reserved:4,
            erasure_progress:4;
#endif
};

struct sel_time_st {
    uint32_t timestamp;                         /* Time in four-byte format. LS byte first.
                                                   See Section 37, Timestamp Format. */
};

#pragma pack()

void ipmi_get_sel_info(struct ipmi_ctx *ctx_cmd);
void ipmi_get_sel_allocation_info(struct ipmi_ctx *ctx_cmd);
void ipmi_reserve_sel(struct ipmi_ctx *ctx_cmd);
void ipmi_get_sel_entry(struct ipmi_ctx *ctx_cmd);
void ipmi_add_sel_entry(struct ipmi_ctx *ctx_cmd);
void ipmi_partial_add_sel_entry(struct ipmi_ctx *ctx_cmd);
void ipmi_del_sel_entry(struct ipmi_ctx *ctx_cmd);
void ipmi_clear_sel_entry(struct ipmi_ctx *ctx_cmd);
void ipmi_get_sel_time(struct ipmi_ctx *ctx_cmd);
void ipmi_set_sel_time(struct ipmi_ctx *ctx_cmd);
void ipmi_get_auxiliary_log_status(struct ipmi_ctx *ctx_cmd);
void ipmi_set_auxiliary_log_status(struct ipmi_ctx *ctx_cmd);


#endif  // __IPMI_SEL_H__

